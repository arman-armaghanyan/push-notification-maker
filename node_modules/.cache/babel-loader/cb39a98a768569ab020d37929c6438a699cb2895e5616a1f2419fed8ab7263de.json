{"ast":null,"code":"import { hexToRgba } from './';\nexport var equalColorObjects = (first, second) => {\n  if (first === second) return true;\n  for (var prop in first) {\n    // The following allows for a type-safe calling of this function (first & second have to be HSL, HSV, or RGB)\n    // with type-unsafe iterating over object keys. TS does not allow this without an index (`[key: string]: number`)\n    // on an object to define how iteration is normally done. To ensure extra keys are not allowed on our types,\n    // we must cast our object to unknown (as RGB demands `r` be a key, while `Record<string, x>` does not care if\n    // there is or not), and then as a type TS can iterate over.\n    if (first[prop] !== second[prop]) return false;\n  }\n  return true;\n};\nexport var equalColorString = (first, second) => {\n  return first.replace(/\\s/g, '') === second.replace(/\\s/g, '');\n};\nexport var equalHex = (first, second) => {\n  if (first.toLowerCase() === second.toLowerCase()) return true;\n\n  // To compare colors like `#FFF` and `ffffff` we convert them into RGB objects\n  return equalColorObjects(hexToRgba(first), hexToRgba(second));\n};\nexport var validHex = hex => /^#?([A-Fa-f0-9]{3,4}){1,2}$/.test(hex);","map":{"version":3,"names":["hexToRgba","equalColorObjects","first","second","prop","equalColorString","replace","equalHex","toLowerCase","validHex","hex","test"],"sources":["/Users/armanarmaghanyan/Documents/Coding/Picsart/pushmaker/node_modules/@uiw/color-convert/esm/utils.js"],"sourcesContent":["import { hexToRgba } from './';\nexport var equalColorObjects = (first, second) => {\n  if (first === second) return true;\n  for (var prop in first) {\n    // The following allows for a type-safe calling of this function (first & second have to be HSL, HSV, or RGB)\n    // with type-unsafe iterating over object keys. TS does not allow this without an index (`[key: string]: number`)\n    // on an object to define how iteration is normally done. To ensure extra keys are not allowed on our types,\n    // we must cast our object to unknown (as RGB demands `r` be a key, while `Record<string, x>` does not care if\n    // there is or not), and then as a type TS can iterate over.\n    if (first[prop] !== second[prop]) return false;\n  }\n  return true;\n};\nexport var equalColorString = (first, second) => {\n  return first.replace(/\\s/g, '') === second.replace(/\\s/g, '');\n};\nexport var equalHex = (first, second) => {\n  if (first.toLowerCase() === second.toLowerCase()) return true;\n\n  // To compare colors like `#FFF` and `ffffff` we convert them into RGB objects\n  return equalColorObjects(hexToRgba(first), hexToRgba(second));\n};\nexport var validHex = hex => /^#?([A-Fa-f0-9]{3,4}){1,2}$/.test(hex);"],"mappings":"AAAA,SAASA,SAAS,QAAQ,IAAI;AAC9B,OAAO,IAAIC,iBAAiB,GAAGA,CAACC,KAAK,EAAEC,MAAM,KAAK;EAChD,IAAID,KAAK,KAAKC,MAAM,EAAE,OAAO,IAAI;EACjC,KAAK,IAAIC,IAAI,IAAIF,KAAK,EAAE;IACtB;IACA;IACA;IACA;IACA;IACA,IAAIA,KAAK,CAACE,IAAI,CAAC,KAAKD,MAAM,CAACC,IAAI,CAAC,EAAE,OAAO,KAAK;EAChD;EACA,OAAO,IAAI;AACb,CAAC;AACD,OAAO,IAAIC,gBAAgB,GAAGA,CAACH,KAAK,EAAEC,MAAM,KAAK;EAC/C,OAAOD,KAAK,CAACI,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,KAAKH,MAAM,CAACG,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;AAC/D,CAAC;AACD,OAAO,IAAIC,QAAQ,GAAGA,CAACL,KAAK,EAAEC,MAAM,KAAK;EACvC,IAAID,KAAK,CAACM,WAAW,CAAC,CAAC,KAAKL,MAAM,CAACK,WAAW,CAAC,CAAC,EAAE,OAAO,IAAI;;EAE7D;EACA,OAAOP,iBAAiB,CAACD,SAAS,CAACE,KAAK,CAAC,EAAEF,SAAS,CAACG,MAAM,CAAC,CAAC;AAC/D,CAAC;AACD,OAAO,IAAIM,QAAQ,GAAGC,GAAG,IAAI,6BAA6B,CAACC,IAAI,CAACD,GAAG,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}