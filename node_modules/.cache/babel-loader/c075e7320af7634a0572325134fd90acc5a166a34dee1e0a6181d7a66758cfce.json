{"ast":null,"code":"var TAU = Math.PI * 2;\n\n/**\n * javascript's modulo operator doesn't produce positive numbers with negative input\n * https://www.geeksforgeeks.org/how-to-get-negative-result-using-modulo-operator-in-javascript/\n */\nexport var mod = (a, n) => (a % n + n) % n;\n\n/** distance between points (x, y) and (0, 0) */\nvar dist = (x, y) => Math.sqrt(x * x + y * y);\n\n/**\n * Get the point as the center of the wheel\n */\nexport function getWheelDimensions(_ref) {\n  var {\n    width = 0\n  } = _ref;\n  var r = width / 2;\n  return {\n    width,\n    radius: r,\n    cx: r,\n    cy: r\n  };\n}\n\n/**\n * Returns true if point (x, y) lands inside the wheel\n */\nexport function isInputInsideWheel(props, x, y) {\n  var {\n    cx,\n    cy,\n    width\n  } = getWheelDimensions(props);\n  var r = width / 2;\n  return dist(cx - x, cy - y) < r;\n}\n\n/**\n * Get the current handle position for a given color\n */\nexport function getWheelHandlePosition(props, hsv) {\n  var {\n    cx,\n    cy\n  } = getWheelDimensions(props);\n  var handleRange = getHandleRange(props);\n  var handleAngle = (180 + translateWheelAngle(props, hsv.h, true)) * (TAU / 360);\n  var handleDist = hsv.s / 100 * handleRange;\n  var direction = props.direction === 'clockwise' ? -1 : 1;\n  return {\n    x: cx + handleDist * Math.cos(handleAngle) * direction,\n    y: cy + handleDist * Math.sin(handleAngle) * direction\n  };\n}\n\n/**\n * Get Range\n */\nexport function getHandleRange(_ref2) {\n  var {\n    width = 0\n  } = _ref2;\n  return width / 2;\n}\n\n/**\n * Translate an angle according to wheelAngle and wheelDirection\n */\nexport function translateWheelAngle(props, angle, invert) {\n  var wheelAngle = props.angle || 0;\n  var direction = props.direction;\n  // inverted and clockwisee\n  if (invert && direction === 'clockwise') angle = wheelAngle + angle;\n  // clockwise (input handling)\n  else if (direction === 'clockwise') angle = 360 - wheelAngle + angle;\n  // inverted and anticlockwise\n  else if (invert && direction === 'anticlockwise') angle = wheelAngle + 180 - angle;\n  // anticlockwise (input handling)\n  else if (direction === 'anticlockwise') angle = wheelAngle - angle;\n  return mod(angle, 360);\n}\n\n/**\n * Get the current wheel value from user input\n * @param props - wheel props\n * @param x - global input x position\n * @param y - global input y position\n */\nexport function getWheelValueFromInput(props, x, y) {\n  var {\n    cx,\n    cy\n  } = getWheelDimensions(props);\n  var handleRange = getHandleRange(props);\n  x = cx - x;\n  y = cy - y;\n  // Calculate the hue by converting the angle to radians\n  var hue = translateWheelAngle(props, Math.atan2(-y, -x) * (360 / TAU));\n  // Find the point's distance from the center of the wheel\n  // This is used to show the saturation level\n  var handleDist = Math.min(dist(x, y), handleRange);\n  return {\n    h: Math.round(hue),\n    s: Math.round(100 / handleRange * handleDist)\n  };\n}","map":{"version":3,"names":["TAU","Math","PI","mod","a","n","dist","x","y","sqrt","getWheelDimensions","_ref","width","r","radius","cx","cy","isInputInsideWheel","props","getWheelHandlePosition","hsv","handleRange","getHandleRange","handleAngle","translateWheelAngle","h","handleDist","s","direction","cos","sin","_ref2","angle","invert","wheelAngle","getWheelValueFromInput","hue","atan2","min","round"],"sources":["/Users/armanarmaghanyan/Documents/GitHub/push-notification-maker/node_modules/@uiw/react-color-wheel/esm/utils.js"],"sourcesContent":["var TAU = Math.PI * 2;\n\n/**\n * javascript's modulo operator doesn't produce positive numbers with negative input\n * https://www.geeksforgeeks.org/how-to-get-negative-result-using-modulo-operator-in-javascript/\n */\nexport var mod = (a, n) => (a % n + n) % n;\n\n/** distance between points (x, y) and (0, 0) */\nvar dist = (x, y) => Math.sqrt(x * x + y * y);\n\n/**\n * Get the point as the center of the wheel\n */\nexport function getWheelDimensions(_ref) {\n  var {\n    width = 0\n  } = _ref;\n  var r = width / 2;\n  return {\n    width,\n    radius: r,\n    cx: r,\n    cy: r\n  };\n}\n\n/**\n * Returns true if point (x, y) lands inside the wheel\n */\nexport function isInputInsideWheel(props, x, y) {\n  var {\n    cx,\n    cy,\n    width\n  } = getWheelDimensions(props);\n  var r = width / 2;\n  return dist(cx - x, cy - y) < r;\n}\n\n/**\n * Get the current handle position for a given color\n */\nexport function getWheelHandlePosition(props, hsv) {\n  var {\n    cx,\n    cy\n  } = getWheelDimensions(props);\n  var handleRange = getHandleRange(props);\n  var handleAngle = (180 + translateWheelAngle(props, hsv.h, true)) * (TAU / 360);\n  var handleDist = hsv.s / 100 * handleRange;\n  var direction = props.direction === 'clockwise' ? -1 : 1;\n  return {\n    x: cx + handleDist * Math.cos(handleAngle) * direction,\n    y: cy + handleDist * Math.sin(handleAngle) * direction\n  };\n}\n\n/**\n * Get Range\n */\nexport function getHandleRange(_ref2) {\n  var {\n    width = 0\n  } = _ref2;\n  return width / 2;\n}\n\n/**\n * Translate an angle according to wheelAngle and wheelDirection\n */\nexport function translateWheelAngle(props, angle, invert) {\n  var wheelAngle = props.angle || 0;\n  var direction = props.direction;\n  // inverted and clockwisee\n  if (invert && direction === 'clockwise') angle = wheelAngle + angle;\n  // clockwise (input handling)\n  else if (direction === 'clockwise') angle = 360 - wheelAngle + angle;\n  // inverted and anticlockwise\n  else if (invert && direction === 'anticlockwise') angle = wheelAngle + 180 - angle;\n  // anticlockwise (input handling)\n  else if (direction === 'anticlockwise') angle = wheelAngle - angle;\n  return mod(angle, 360);\n}\n\n/**\n * Get the current wheel value from user input\n * @param props - wheel props\n * @param x - global input x position\n * @param y - global input y position\n */\nexport function getWheelValueFromInput(props, x, y) {\n  var {\n    cx,\n    cy\n  } = getWheelDimensions(props);\n  var handleRange = getHandleRange(props);\n  x = cx - x;\n  y = cy - y;\n  // Calculate the hue by converting the angle to radians\n  var hue = translateWheelAngle(props, Math.atan2(-y, -x) * (360 / TAU));\n  // Find the point's distance from the center of the wheel\n  // This is used to show the saturation level\n  var handleDist = Math.min(dist(x, y), handleRange);\n  return {\n    h: Math.round(hue),\n    s: Math.round(100 / handleRange * handleDist)\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}